# GitHub Copilot - Software Development Best Practices Ruleset

## Purpose
This document defines the best practices and conventions for software development in this project, optimized for collaboration with GitHub Copilot AI assistant.

---

## üèóÔ∏è Project Architecture Principles

### 1. Structure by Business Components
- **Rule**: Organize code by business domain/features, not by technical layers
- **Example**: `leaves/`, `employee-profile/`, `payroll-execution/` (NOT `controllers/`, `services/`, `models/`)
- **Apply**: When creating new features, create a self-contained module with its own controllers, services, and models

### 2. Layer Your Components (3-Tier Pattern)
- **Entry Points**: Controllers, API routes, message queue consumers
- **Domain Layer**: Business logic, DTOs, services, validations
- **Data Access**: Database queries, ORM models, repositories
- **Rule**: Never pass HTTP-specific objects (Request/Response) to domain layer

### 3. Wrap Common Utilities as Packages
- **Rule**: Reusable code goes in `libraries/` or `shared/` with its own `package.json`
- **Example**: Logger, authenticator, validators should be independent modules
- **Benefit**: Enables future extraction to npm packages

### 4. Environment Configuration
- **Rule**: Use environment-aware, hierarchical config with validation
- **Tools**: `@nestjs/config`, `joi`, `dotenv`
- **Must Have**:
  - Default values for all keys
  - Type validation
  - Fail-fast on missing required vars
  - Secrets NEVER in code

---

## üéØ Code Quality Standards

### SOLID Principles

#### Single Responsibility Principle (SRP)
- **Rule**: Each class/function should have ONE reason to change
- **Example**: Separate `AuthService` (authentication) from `UserService` (user management)

#### Open/Closed Principle (OCP)
- **Rule**: Open for extension, closed for modification
- **Apply**: Use strategies, plugins, middleware instead of modifying existing code

#### Liskov Substitution Principle (LSP)
- **Rule**: Subtypes must be substitutable for their base types
- **Apply**: Child classes should not break parent class behavior

#### Interface Segregation Principle (ISP)
- **Rule**: Don't force clients to depend on interfaces they don't use
- **Apply**: Create focused, specific interfaces rather than fat ones

#### Dependency Inversion Principle (DIP)
- **Rule**: Depend on abstractions, not concretions
- **Apply**: Use dependency injection, inject interfaces not implementations

---

## üßπ Clean Code Practices

### Naming Conventions

```typescript
// Constants - UPPER_SNAKE_CASE
const MAX_RETRY_ATTEMPTS = 3;
const API_BASE_URL = 'https://api.example.com';

// Variables & Functions - camelCase
const userCount = 10;
function getUserById(id: string) { }

// Classes - PascalCase
class UserService { }
class EmployeeProfile { }

// Interfaces - PascalCase with 'I' prefix (TypeScript)
interface IUserRepository { }

// Types - PascalCase
type UserId = string;
```

### Function Guidelines

1. **Function Arguments**: Max 2-3 parameters
   ```typescript
   // ‚ùå Bad
   function createUser(name, email, age, role, department, manager) { }
   
   // ‚úÖ Good
   interface CreateUserDto {
     name: string;
     email: string;
     age: number;
     role: string;
     department: string;
     managerId?: string;
   }
   function createUser(dto: CreateUserDto) { }
   ```

2. **Single Purpose**: One function = one action
   ```typescript
   // ‚ùå Bad
   function emailClients(clients) {
     clients.forEach(client => {
       const record = db.lookup(client);
       if (record.isActive()) email(client);
     });
   }
   
   // ‚úÖ Good
   function emailActiveClients(clients) {
     return clients.filter(isActiveClient).forEach(sendEmail);
   }
   ```

3. **Descriptive Names**: Function name should explain what it does
   ```typescript
   // ‚ùå Bad
   function addToDate(date, month) { }
   
   // ‚úÖ Good
   function addMonthsToDate(date: Date, months: number): Date { }
   ```

4. **Avoid Side Effects**: Pure functions when possible
   ```typescript
   // ‚ùå Bad (mutates input)
   function addItem(cart, item) {
     cart.push(item);
   }
   
   // ‚úÖ Good (immutable)
   function addItem(cart, item) {
     return [...cart, item];
   }
   ```

5. **No Flags as Parameters**: Split into separate functions
   ```typescript
   // ‚ùå Bad
   function createFile(name, isTemp) { }
   
   // ‚úÖ Good
   function createFile(name) { }
   function createTempFile(name) { createFile(`./temp/${name}`); }
   ```

### Variable Best Practices

1. **Meaningful Names**: Avoid abbreviations
   ```typescript
   // ‚ùå Bad
   const yyyymmdstr = moment().format('YYYY/MM/DD');
   
   // ‚úÖ Good
   const currentDate = moment().format('YYYY/MM/DD');
   ```

2. **Searchable Names**: No magic numbers
   ```typescript
   // ‚ùå Bad
   setTimeout(blastOff, 86400000);
   
   // ‚úÖ Good
   const MILLISECONDS_PER_DAY = 60 * 60 * 24 * 1000;
   setTimeout(blastOff, MILLISECONDS_PER_DAY);
   ```

3. **Use Default Parameters**
   ```typescript
   // ‚ùå Bad
   function createUser(name) {
     const userName = name || 'Guest';
   }
   
   // ‚úÖ Good
   function createUser(name = 'Guest') { }
   ```

---

## üß™ Testing Standards

### Testing Pyramid
1. **Unit Tests**: 70% - Test individual functions/methods
2. **Integration Tests**: 20% - Test API endpoints, database interactions
3. **E2E Tests**: 10% - Test complete user workflows

### Test Structure (AAA Pattern)
```typescript
describe('UserService', () => {
  it('should create user when valid data provided', async () => {
    // Arrange - Setup
    const dto = { name: 'John', email: 'john@example.com' };
    const mockRepo = { save: jest.fn() };
    
    // Act - Execute
    const result = await userService.createUser(dto);
    
    // Assert - Verify
    expect(result).toBeDefined();
    expect(mockRepo.save).toHaveBeenCalledWith(dto);
  });
});
```

### Test Naming Convention
```typescript
// Pattern: should [expected behavior] when [condition]
it('should return 404 when user not found', () => { });
it('should throw error when email already exists', () => { });
it('should update balance when transaction succeeds', () => { });
```

### Testing Rules
- **One Concept Per Test**: Each test should verify one thing
- **No Global Fixtures**: Each test sets up its own data
- **Mock External Services**: Use nock, mock-server for HTTP calls
- **Test Five Outcomes**:
  1. Response returned
  2. State changed (DB)
  3. External API called
  4. Message queued
  5. Observable action (log/metric)

---

## üõ°Ô∏è Error Handling

### Always Use Try-Catch with Async/Await
```typescript
// ‚ùå Bad
function getData() {
  return fetch('/api/data')
    .then(res => res.json())
    .catch(err => console.log(err));
}

// ‚úÖ Good
async function getData() {
  try {
    const response = await fetch('/api/data');
    return await response.json();
  } catch (error) {
    logger.error('Failed to fetch data', { error });
    throw new DataFetchError('Unable to retrieve data', { cause: error });
  }
}
```

### Custom Error Classes
```typescript
export class AppError extends Error {
  constructor(
    message: string,
    public readonly code: string,
    public readonly statusCode: number,
    public readonly isOperational: boolean = true,
  ) {
    super(message);
    Object.setPrototypeOf(this, AppError.prototype);
  }
}

// Usage
throw new AppError('User not found', 'USER_NOT_FOUND', 404);
```

### Distinguish Error Types
- **Operational Errors**: Expected errors (validation, not found, unauthorized)
- **Programmer Errors**: Bugs (null reference, wrong type)
- **Rule**: Handle operational errors, let programmer errors crash (and restart)

---

## üîê Security Best Practices

### 1. Authentication & Authorization
- **Rule**: Always validate JWT tokens
- **Rule**: Check permissions at route level (Guards)
- **Rule**: Use httpOnly cookies for tokens (prevent XSS)
- **Rule**: Implement rate limiting

### 2. Input Validation
```typescript
// ‚úÖ Always validate and sanitize input
import { IsEmail, IsNotEmpty, MinLength } from 'class-validator';

export class LoginDto {
  @IsEmail()
  @IsNotEmpty()
  email: string;

  @MinLength(8)
  @IsNotEmpty()
  password: string;
}
```

### 3. Secrets Management
- **Never**: Commit secrets to git
- **Always**: Use `.env` files (gitignored)
- **Always**: Use secret managers in production (AWS Secrets Manager, Azure Key Vault)
- **Always**: Rotate secrets regularly

### 4. SQL Injection Prevention
- **Always**: Use parameterized queries or ORM
- **Never**: Concatenate user input into SQL strings

### 5. Dependency Security
- **Run**: `npm audit` regularly
- **Fix**: Update vulnerable dependencies immediately
- **Use**: Dependabot or Snyk for automated checks

---

## üê≥ Docker Best Practices

### Multi-Stage Builds
```dockerfile
# Build stage
FROM node:18-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

# Production stage
FROM node:18-alpine
WORKDIR /app
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/node_modules ./node_modules
COPY package*.json ./
USER node
EXPOSE 3000
CMD ["node", "dist/main.js"]
```

### Docker Rules
1. **Use `.dockerignore`**: Exclude secrets, node_modules, .git
2. **Multi-stage builds**: Smaller, more secure images
3. **Specific tags**: Never use `latest`, pin versions
4. **Run as non-root**: Use `USER node`
5. **Clean npm cache**: `RUN npm ci --only=production && npm cache clean --force`

---

## üì¶ Git Best Practices

### Commit Message Format
```
type(scope): subject

body (optional)

footer (optional)
```

**Types**: `feat`, `fix`, `docs`, `style`, `refactor`, `test`, `chore`

**Examples**:
```
feat(leaves): add leave balance tracking endpoint
fix(auth): resolve JWT expiration issue
docs(readme): update installation instructions
refactor(payroll): extract salary calculation logic
```

### Branch Strategy
```
main (production)
  ‚îî‚îÄ develop (staging)
       ‚îú‚îÄ feature/leaves-balance
       ‚îú‚îÄ feature/employee-onboarding
       ‚îú‚îÄ fix/auth-token-refresh
       ‚îî‚îÄ hotfix/critical-bug
```

### Rules
- **Never commit directly to `main`**
- **Create PR for all changes**
- **Squash commits before merging**
- **Delete branches after merge**

---

## üöÄ Production Readiness

### Logging
```typescript
// Use structured logging
logger.info('User logged in', {
  userId: user.id,
  email: user.email,
  timestamp: new Date().toISOString(),
  ip: req.ip,
});
```

### Monitoring
- **Health checks**: `/health` endpoint
- **Metrics**: Response time, error rate, active connections
- **APM**: Use New Relic, DataDog, or Application Insights
- **Alerting**: Set up alerts for errors, high latency, downtime

### Performance
- **Database**: Use indexes, avoid N+1 queries
- **Caching**: Redis for frequently accessed data
- **Load Balancing**: Distribute traffic across instances
- **Rate Limiting**: Prevent abuse

---

## ü§ñ Working with GitHub Copilot - Optimization Rules

### 1. Provide Context Upfront
**Do this FIRST when starting work:**
```
I'm working on [feature]. The codebase structure is:
- Backend: NestJS with MongoDB
- Frontend: Next.js 16 with React 19
- Auth: JWT in httpOnly cookies
- Key files: [list relevant files]
```

### 2. Be Specific in Requests
```
‚ùå "Fix the login bug"
‚úÖ "The /auth/me endpoint returns 500. It uses @Res() which bypasses 
   NestJS serialization. Change to @Req() and return req.user directly."
```

### 3. Request Batched Operations
```
‚úÖ "Update all 4 tracking controller methods to use req.user.id 
   instead of req.user._id in one operation"
```

### 4. Use Read Context Efficiently
```
‚úÖ "Read backend/src/auth/strategies/jwt.strategy.ts lines 1-51 
   to understand the user object structure"
```

### 5. Leverage Multi-Replace
```
‚úÖ "Use multi_replace_string_in_file to update all instances of 
   req.user._id to req.user.id in tracking.controller.ts"
```

### 6. Create Todo Lists for Complex Work
```
‚úÖ "Create todo list:
   1. Fix authentication endpoint
   2. Update tracking controller
   3. Add permission checks
   4. Fix React hydration warnings"
```

### 7. Provide File Patterns
```
‚úÖ "Search for all files matching **/*controller.ts that use req.user._id"
```

### 8. Request Validation After Changes
```
‚úÖ "After updating auth.controller.ts, use get_errors to validate 
   no TypeScript compilation errors"
```

### 9. Ask for Complete Solutions
```
‚ùå "How do I fix this?"
‚úÖ "Implement the fix by replacing lines X-Y in file.ts with the 
   corrected code"
```

### 10. Reference Existing Patterns
```
‚úÖ "Follow the same pattern used in employee-profile.controller.ts 
   for the new leaves controller"
```

---

## üìã Project-Specific Conventions

### Backend (NestJS)

#### Module Structure
```
module-name/
  ‚îú‚îÄ‚îÄ module-name.module.ts
  ‚îú‚îÄ‚îÄ module-name.controller.ts
  ‚îú‚îÄ‚îÄ module-name.service.ts
  ‚îú‚îÄ‚îÄ dto/
  ‚îÇ   ‚îú‚îÄ‚îÄ create-module.dto.ts
  ‚îÇ   ‚îî‚îÄ‚îÄ update-module.dto.ts
  ‚îú‚îÄ‚îÄ entities/ or Models/
  ‚îÇ   ‚îî‚îÄ‚îÄ module.entity.ts
  ‚îî‚îÄ‚îÄ enums/
      ‚îî‚îÄ‚îÄ module-status.enum.ts
```

#### Controller Guidelines
```typescript
@Controller('api/v1/module-name')
export class ModuleController {
  constructor(private readonly service: ModuleService) {}

  @Get()
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles('ADMIN', 'MANAGER')
  async findAll(@Query() query: QueryDto) {
    return this.service.findAll(query);
  }

  @Post()
  @UseGuards(JwtAuthGuard)
  async create(@Body() dto: CreateDto, @Req() req: any) {
    return this.service.create(dto, req.user.id);
  }
}
```

#### Service Guidelines
```typescript
@Injectable()
export class ModuleService {
  constructor(
    @InjectModel(Model.name) private model: Model<ModelDocument>,
    private readonly logger: LoggerService,
  ) {}

  async findById(id: string): Promise<ModelDocument> {
    const doc = await this.model.findById(id).exec();
    if (!doc) {
      throw new NotFoundException(`Model with ID ${id} not found`);
    }
    return doc;
  }
}
```

### Frontend (Next.js + React)

#### Component Structure
```
components/
  ‚îú‚îÄ‚îÄ ui/              # Reusable UI components
  ‚îú‚îÄ‚îÄ forms/           # Form components
  ‚îú‚îÄ‚îÄ layouts/         # Layout components
  ‚îî‚îÄ‚îÄ features/        # Feature-specific components
```

#### Component Guidelines
```typescript
'use client'; // Only if using hooks/state

import { useState } from 'react';

interface ComponentProps {
  title: string;
  onSubmit: (data: FormData) => void;
}

export function Component({ title, onSubmit }: ComponentProps) {
  const [loading, setLoading] = useState(false);

  return (
    <div>
      <h1>{title}</h1>
      {/* Component JSX */}
    </div>
  );
}
```

#### State Management
- **Simple state**: `useState`
- **Complex state**: `useReducer`
- **Server state**: `@tanstack/react-query`
- **Global state**: Context API or Zustand

---

## üéì Learning Resources

### Books
- Clean Code by Robert C. Martin
- Design Patterns by Gang of Four
- Refactoring by Martin Fowler

### Online Resources
- Node.js Best Practices: https://github.com/goldbergyoni/nodebestpractices
- Clean Code JavaScript: https://github.com/ryanmcdermott/clean-code-javascript
- TypeScript Best Practices: https://www.typescriptlang.org/docs/handbook/

---

## üìù Checklist Before Committing

- [ ] All tests pass (`npm test`)
- [ ] No linting errors (`npm run lint`)
- [ ] No TypeScript errors (`npm run build`)
- [ ] Code follows naming conventions
- [ ] Functions are < 50 lines
- [ ] No console.log statements
- [ ] Error handling implemented
- [ ] Input validation added
- [ ] Documentation updated
- [ ] Performance considered
- [ ] Security reviewed
- [ ] No secrets in code

---

## üîÑ Code Review Checklist

### Functionality
- [ ] Does it work as intended?
- [ ] Are edge cases handled?
- [ ] Are errors handled properly?

### Code Quality
- [ ] Is the code readable?
- [ ] Are names meaningful?
- [ ] Is there duplicated code?
- [ ] Are functions doing one thing?

### Testing
- [ ] Are there tests?
- [ ] Do tests cover edge cases?
- [ ] Are tests readable?

### Security
- [ ] Is user input validated?
- [ ] Are secrets protected?
- [ ] Are SQL queries parameterized?

### Performance
- [ ] Are there N+1 query issues?
- [ ] Is caching appropriate?
- [ ] Are large operations paginated?

---

## üí° Remember

> "Any fool can write code that a computer can understand. 
> Good programmers write code that humans can understand." 
> ‚Äî Martin Fowler

**Quality > Speed**: Take time to write clean, maintainable code.
**Refactor Ruthlessly**: Improve code continuously.
**Test Everything**: Tests are documentation and safety nets.
**Keep Learning**: Software development constantly evolves.

---

*Last Updated: December 15, 2024*
*Project: Semester 5 Software Project*
*Team: Development Team*
